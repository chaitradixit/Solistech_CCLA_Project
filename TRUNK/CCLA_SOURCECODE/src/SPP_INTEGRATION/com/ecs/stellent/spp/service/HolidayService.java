package com.ecs.stellent.spp.service;

import java.util.Calendar;
import java.util.Date;

import com.ecs.ucm.ccla.CCLAUtils;
import com.ecs.ucm.ccla.cache.HolidayDateUtils;
import com.ecs.ucm.ccla.utils.DateUtils;
import com.ecs.utils.StringUtils;
import com.ecs.utils.stellent.BinderUtils;
import com.ecs.utils.stellent.embedded.FWFacade;

import intradoc.common.ServiceException;
import intradoc.data.DataBinder;
import intradoc.data.DataException;
import intradoc.data.DataResultSet;
import intradoc.server.Service;

public class HolidayService extends Service 
{

	//Array of the common holidays
	public static final HolidayDate[] commonHolidays = {
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DATE, "New Years", 1, -1, 1, new int[] {Calendar.SATURDAY, Calendar.SUNDAY},new int[]{Calendar.MONDAY,Calendar.MONDAY}),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_EASTER_GOOD_FRIDAY, "Good Friday",-1, -1, -1, null, null),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_EASTER_MONDAY, "Easter Monday",-1, -1, -1, null, null),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DAY_FIRST_WEEK, "Early May Bank Holiday",-1, Calendar.MONDAY, 5, null,null),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DAY_LAST_WEEK, "Spring Bank Holiday",-1 , Calendar.MONDAY, 5, null, null),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DAY_LAST_WEEK, "Summer Bank Holiday",25, Calendar.MONDAY, 8, null,null),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DATE, "Christmas Day",25, -1, 12, new int[]{Calendar.SATURDAY, Calendar.SUNDAY}, new int[]{Calendar.MONDAY,Calendar.MONDAY}),
		new HolidayDate(HolidayDate.HOLIDAY_TYPE_DATE, "Boxing Day" ,26, -1, 12, new int[] {Calendar.SATURDAY, Calendar.SUNDAY, Calendar.MONDAY},new int[]{Calendar.MONDAY,Calendar.TUESDAY,Calendar.TUESDAY})
	};
	
	public void addAutoGeneratedHoliday() throws DataException, ServiceException
	{
		int year = BinderUtils.getBinderIntegerValue(m_binder,"YEAR");
		
		FWFacade facade = CCLAUtils.getFacade(m_workspace,true);
		
		DataBinder binder = new DataBinder();
		for (int i=0; i<commonHolidays.length; i++) 
		{
			commonHolidays[i].getHoliday(year);
			
			// Allocate new ID.
			int id = Integer.parseInt(CCLAUtils.getNewKey("PublicHoliday", facade));
			BinderUtils.addIntParamToBinder(binder, "HOLIDAY_ID", id);
			binder.putLocal("description", commonHolidays[i].getDescription());
			binder.putLocalDate("holidayDate", commonHolidays[i].getHoliday(year));
			facade.execute("qAddPublicHoliday", binder);
		}
		
		if (DateUtils.getYear(DateUtils.getNow())==year)
			HolidayDateUtils.getCache().buildCache(facade);
	}
	
	public void deleteHoliday() throws DataException, ServiceException 
	{
		String idToDel = m_binder.get("idToDel");
		int year = BinderUtils.getBinderIntegerValue(m_binder, "YEAR");

		
		if (StringUtils.stringIsBlank(idToDel))
			throw new DataException("No id specified, cannot delete.");
		
		DataBinder binder = new DataBinder();
		binder.putLocal("id", idToDel);

		FWFacade facade = CCLAUtils.getFacade(m_workspace,true);
		facade.execute("qDeletePublicHoliday", binder);		
		
		if (DateUtils.getYear(DateUtils.getNow())==year)
			HolidayDateUtils.getCache().buildCache(facade);
	}
	
	
	public void addHoliday() throws DataException, ServiceException 
	{
		String description = null;
		Date holidayDate = null;
		
		int year = BinderUtils.getBinderIntegerValue(m_binder, "YEAR");
		int month = BinderUtils.getBinderIntegerValue(m_binder, "MONTH");
		int day = BinderUtils.getBinderIntegerValue(m_binder, "DAY");
		description = BinderUtils.getBinderStringValue(m_binder, "DESCRIPTION");
		
		holidayDate = DateUtils.getDate(year, month, day);
		
		if (holidayDate==null)
			throw new DataException("Invalid date params.");
		
		FWFacade facade = CCLAUtils.getFacade(m_workspace,true);
		DataBinder binder = new DataBinder();
		
		binder.putLocalDate("holidayDate", holidayDate);
		binder.putLocal("description", description);
		
		// Allocate new ID.
		int id = Integer.parseInt(CCLAUtils.getNewKey("PublicHoliday", facade));
		BinderUtils.addIntParamToBinder(binder, "HOLIDAY_ID", id);
		
		facade.execute("qAddPublicHoliday", binder);	
		
		if (DateUtils.getYear(DateUtils.getNow())==year)
			HolidayDateUtils.getCache().buildCache(facade);
	}
	
	public void getHolidays() throws DataException, ServiceException 
	{
		int year = 0;
		String yearStr = null;
		
		try {
			yearStr = m_binder.get("YEAR");
		} catch (DataException de) {
			//Assume this is first time entering the page.
			yearStr = null;
		}
		
		if (StringUtils.stringIsBlank(yearStr)) {
			//always assume current year
			year = DateUtils.getYear(DateUtils.getNow());
		} else {
			try {
				year = Integer.parseInt(yearStr);
			} catch (NumberFormatException ne) {
				throw new DataException("Cannot parse year "+yearStr);
			}
		}
		//Get the start date, 1/1
		Date startDate = DateUtils.getDate(year, 1, 1);		
		//Get the end date 31/12
		Date endDate = DateUtils.getDate(year, 12, 31);
		
		if (year==0 || startDate==null || endDate==null) {
			throw new DataException("invalid date");			
		}
		
		DataBinder binder = new DataBinder();
		binder.putLocalDate("startDate", startDate);
		binder.putLocalDate("endDate", endDate);
		
		FWFacade facade = CCLAUtils.getFacade(m_workspace,true);
		DataResultSet results = facade.createResultSet("qGetPublicHoliday", binder);
		
		m_binder.addResultSet("rsHolidays", results);
		m_binder.putLocal("YEAR", String.valueOf(year));
		
	}
	
	private static class HolidayDate {
		
		public static final int HOLIDAY_TYPE_UNDEFINED 				= -1;
		public static final int HOLIDAY_TYPE_DATE 					= 0;
		public static final int HOLIDAY_TYPE_DAY_FIRST_WEEK 		= 1;
		public static final int HOLIDAY_TYPE_DAY_LAST_WEEK 			= 2;
		public static final int HOLIDAY_TYPE_EASTER_SUNDAY 			= 3;
		public static final int HOLIDAY_TYPE_EASTER_GOOD_FRIDAY 	= 4;
		public static final int HOLIDAY_TYPE_EASTER_MONDAY 			= 5;
		
		private int type = HOLIDAY_TYPE_UNDEFINED;
		private int[] rolloverDates = null;
		private	int month = Calendar.JANUARY; //default
		private int day = Calendar.MONDAY; //default
		private int date = 0; //default
		private int[] matchingDates = null;
		private String description = null;	

		public HolidayDate(int type, String description, int date, int day, int month, int[] matchingDates, int[] rolloverDates) {
			this.type = type;
			this.date = date;
			this.day = day;
			this.month = month;
			this.rolloverDates = rolloverDates;
			this.matchingDates = matchingDates;
			this.description = description;
		}
		
		public String getDescription() {
			return description;
		}
		
		public Date getHoliday(int year) 
		{
			if (type==HOLIDAY_TYPE_UNDEFINED) {
				return null;
			}
			
			if (type==HOLIDAY_TYPE_EASTER_SUNDAY || 
					type==HOLIDAY_TYPE_EASTER_MONDAY ||
						type==HOLIDAY_TYPE_EASTER_GOOD_FRIDAY) {
				
				Date result = null;
				
				int a = year % 19;
				int b = year / 100;
				int c = year % 100;
				int d = b / 4;
				int e = b % 4;
				int f = ( b + 8 ) / 25;
				int g = ( b - f + 1 ) / 3;
				int h = ( 19 * a + b - d - g + 15 ) % 30;
				int i = c / 4;
				int k = c % 4;
				int l = (32 + 2 * e + 2 * i - h - k) % 7;
				int m = (a + 11 * h + 22 * l) / 451;
				int p = (h + l - 7 * m + 114) % 31;

				int month = ( h + l - 7 * m + 114 ) / 31;
				int day = p + 1;

				result = DateUtils.getDate(year, month, day);
				
				if (type==HOLIDAY_TYPE_EASTER_SUNDAY)
					return result;
				else if (type==HOLIDAY_TYPE_EASTER_GOOD_FRIDAY)
					return DateUtils.roundToPreviousDayOfWeek(result, Calendar.FRIDAY);
				else if (type==HOLIDAY_TYPE_EASTER_MONDAY) 
					return DateUtils.roundToNextDayOfWeek(result, Calendar.MONDAY);
				
			} else if (type==HOLIDAY_TYPE_DATE) {
				
				Date result = DateUtils.getDate(year, month, date);
				
				if (result==null)
					return result;
				
				for(int i=0; i<matchingDates.length;i++) {
					if (DateUtils.getDayOfWeek(result)==matchingDates[i]) {					
						result = DateUtils.roundToNextDayOfWeek(result,rolloverDates[i]);
						break;
					}
				}
				
				
				return result;
				
			} else if (type==HOLIDAY_TYPE_DAY_FIRST_WEEK || 
						type==HOLIDAY_TYPE_DAY_LAST_WEEK) {
				
				Date result = DateUtils.getDate(year, month, 1);
				if (result==null)
					return result;
				
				if (type==HOLIDAY_TYPE_DAY_FIRST_WEEK) {
					return DateUtils.roundToNextDayOfWeek(result, day);					
				} else if (type==HOLIDAY_TYPE_DAY_LAST_WEEK) {
					result = DateUtils.roundToLastDayOfMonth(result);
					return DateUtils.roundToPreviousDayOfWeek(result, day);
				}
			}			
			return null;
		}
	}

}
