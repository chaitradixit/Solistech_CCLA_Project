package com.ecs.ucm.ccla.commproc;

import intradoc.common.ServiceException;
import intradoc.data.DataException;
import intradoc.shared.SharedObjects;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.Vector;
import java.util.Map.Entry;

import com.ecs.ucm.ccla.CCLAUtils;
import com.ecs.ucm.ccla.CacheManager;
import com.ecs.ucm.ccla.Globals;
import com.ecs.ucm.ccla.commproc.modulehandler.AbstractModuleHandler;
import com.ecs.ucm.ccla.commproc.modulehandler.RoutingModuleHandler;
import com.ecs.ucm.ccla.data.SystemConfigVar;
import com.ecs.ucm.ccla.data.instruction.Instruction;
import com.ecs.ucm.ccla.data.instruction.InstructionAction;
import com.ecs.ucm.ccla.data.instruction.InstructionActionApplied;
import com.ecs.ucm.ccla.data.instruction.InstructionProcess;
import com.ecs.ucm.ccla.data.instruction.ModuleRuleApplied;
import com.ecs.ucm.ccla.data.instruction.RoutingModule;
import com.ecs.utils.Log;
import com.ecs.utils.stellent.embedded.FWFacade;

/** Responsible for managing the RoutingModule instances and pushing Instruction
 *  entries between them.
 *  
 *  This runs as a separate Thread. The start() method should be invoked on server
 *  startup.
 *  
 * @author Tom
 *
 */
public class RoutingModuleManager implements Runnable {
	
	/** Singleton instance of RoutingModuleManager.
	 * 
	 */
	private static RoutingModuleManager manager;
	
	/** Time in ms to rest between each module execution. Figure given here is a
	 *  default, and may be overwritten during initialization */
	public static int INTER_MODULE_REST_PERIOD = 100;
	/** Time in ms to rest between each cycle of module executions.  Figure given here 
	 *  is a default, and may be overwritten during initialization. */
	public static int INTER_CYCLE_REST_PERIOD  = 10000;
	
	/** Limit on the total number of instructions that will be fetched and processed
	 *  per module.  Figure given here is a default, and may be overwritten during
	 *  initialization. */
	public static int NUM_INSTRUCTIONS_TO_PROCESS = 30;
	
	/** Allowed execution period (in seconds) for each module. Before processing each
	 *  fetched instruction, the elapsed execution time is checked to see if it exceeds
	 *  this limit. If its exceeded, remaining processing for that module is cancelled
	 *  until the next cycle.
	 */
	public static int MODULE_EXECUTION_TIMEOUT_PERIOD = 180;
	
	/** Store of all active RoutingModule instances */
	private TreeMap<Integer,RoutingModule> routingModules;
	
	/** Stores the date of the Routing Module cache used to build the ordered
	 *  routingModules list.
	 */
	private Date lastRoutingModuleRefresh = null;
	
	/** Used to store errors generated by the routing modules while processing
	 *  Instructions.
	 */
	private InstructionErrorSpooler errorSpooler;
	
	/** Determines whether the module checking loop has been suspended. */
	private boolean paused 	= false;
	
	private int startModuleManagerPaused = 
		SharedObjects.getEnvironmentInt("CCLA_CommProc_StartModuleManagerPaused", 0);
	
	/** Determines whether this is the first run */
	private boolean isFirstRun = true;
	
	/** Determines whether the run method is inside the module checking loop. */
	private boolean busy	= false;
	
	/** Records the date that the system was last unpaused, i.e. the total up time.
	 * 
	 */
	private Date dateActive = null;
	
	/** System time in milliseconds when the last module kicked off its execution cycle.
	 * 
	 */
	private Long moduleProcessingStartTime;
	
	/** Records the last cycle date
	 * 
	 */
	private Date lastCycle = null;
	
	private Boolean isModulesListStale = false;
	
	/** Records the total number of monitor cycles.
	 * 
	 */
	private double numCycles = 0;
	
	public static final class ConfigVars {
		public static final String INTER_CYCLE_REST_PERIOD = 
		 "CommProc_InterCycleRestPeriod";
		public static final String INTER_MODULE_REST_PERIOD = 
		 "CommProc_InterModuleRestPeriod";
		public static final String NUM_INSTRUCTIONS_TO_PROCESS = 
		 "CommProc_NumInstructionsToProcess";
		public static final String MODULE_EXECUTION_TIMEOUT_PERIOD = 
		 "CommProc_ModuleExecutionTimeoutPeriod";
	}
	
	/** Used to capture the current Module execution status.
	 * 
	 * @author tm
	 *
	 */
	public static class ModuleExecutionStatus {
		private RoutingModule currentModule;
		
		private int numFetchedInstructions;
		private int numProcessedInstructions;
		
		private ExecutionStatus executionStatus;
		
		public static enum ExecutionStatus {
			FETCHING_INSTRUCTIONS,
			PROCESSING,
			CLEAN_UP
		}
		
		private ModuleExecutionStatus(RoutingModule currentModule) {
			this.currentModule = currentModule;
		}
		
		private void setNumProcessedInstructions(int numProcessedInstructions) {
			this.numProcessedInstructions = numProcessedInstructions;
		}
		
		private void setNumFetchedInstructions(int numFetchedInstructions) {
			this.numFetchedInstructions = numFetchedInstructions;
		}
		
		private void setExecutionStatus(ExecutionStatus executionStatus) {
			this.executionStatus = executionStatus;
		}
		
		public RoutingModule getCurrentModule() {
			return currentModule;
		}
		public int getNumFetchedInstructions() {
			return numFetchedInstructions;
		}
		public int getNumProcessedInstructions() {
			return numProcessedInstructions;
		}
		
		public ExecutionStatus getExecutionStatus() {
			return executionStatus;
		}
	}
	
	private ModuleExecutionStatus moduleExecutionStatus;
	
	public ModuleExecutionStatus getModuleExecutionStatus() {
		return moduleExecutionStatus;
	}
	
	public RoutingModuleManager() throws ServiceException {
		if (getManager() != null)
			throw new ServiceException("Routing Module Manager already created");
		
		setManager(this);
	}
	
	public void init(FWFacade facade) throws DataException {
		
		// Load Routing Module caches
		CacheManager.addCacheAndInit(InstructionProcess.getCache(), facade);
		
		CacheManager.addCacheAndInit(InstructionAction.getCache(), facade);
		CacheManager.addCacheAndInit(InstructionActionApplied.getCache(), facade);

		CacheManager.addCacheAndInit(ModuleRuleApplied.getCache(), facade);
		CacheManager.addCacheAndInit(RoutingModule.getCache(), facade);
		
		errorSpooler = new InstructionErrorSpooler();
		
		// Fetch all Routing Modules from the Cache
		buildModulesList();
	}
	
	public void run() {
		Log.debug("Started Routing Module Manager thread.");
		
		while (true) {
			
			// if first run rest a bit
			if(isFirstRun){
				if (startModuleManagerPaused == 1)
					paused = true;
				
				try {
					Thread.sleep(INTER_CYCLE_REST_PERIOD);
					isFirstRun = false;
				} catch (InterruptedException e) {}
			}
			
			while (paused) {
				// Rest a bit before checking the pause state again.
				try {
					Thread.sleep(INTER_MODULE_REST_PERIOD);
				} catch (InterruptedException e) {}
			}
			
			// Apply changes to config variables
			updateConfigVars();
			
			// Execute a process cycle for every single registered
			// module.
			checkModules();
			lastCycle = new Date();
			numCycles++;
			
			// Rest a bit between each module check cycle
			try {
				Thread.sleep(INTER_CYCLE_REST_PERIOD);
			} catch (InterruptedException e) {}
		}
	}
	
	private void updateConfigVars() {
		
		try {
			SystemConfigVar interModuleRestPeriod = SystemConfigVar.getCache()
			 .getCachedInstance(ConfigVars.INTER_MODULE_REST_PERIOD);
			
			if (interModuleRestPeriod != null)
				INTER_MODULE_REST_PERIOD = interModuleRestPeriod.getIntValue();
			
			SystemConfigVar interCycleRestPeriod = SystemConfigVar.getCache()
			 .getCachedInstance(ConfigVars.INTER_CYCLE_REST_PERIOD);
			
			if (interCycleRestPeriod != null)
				INTER_CYCLE_REST_PERIOD = interCycleRestPeriod.getIntValue();
			
			SystemConfigVar numInstructionsToProcess = SystemConfigVar.getCache()
			 .getCachedInstance(ConfigVars.NUM_INSTRUCTIONS_TO_PROCESS);
			
			if (numInstructionsToProcess != null)
			 NUM_INSTRUCTIONS_TO_PROCESS = numInstructionsToProcess.getIntValue();
			
			SystemConfigVar moduleExecutionTimeoutPeriod = SystemConfigVar.getCache()
			 .getCachedInstance(ConfigVars.MODULE_EXECUTION_TIMEOUT_PERIOD);
			
			if (moduleExecutionTimeoutPeriod != null)
				MODULE_EXECUTION_TIMEOUT_PERIOD = moduleExecutionTimeoutPeriod.getIntValue();
			
		} catch (Exception e) {
			DataException de = new DataException
			 ("Failed to update config vars: " + e.getMessage(), e);
			
			this.errorSpooler.append(null, null, de);
			this.setPaused(true);
		}
		
		/*
		Log.debug("Routing Module Manager config vars: " 
		 + ConfigVars.INTER_CYCLE_REST_PERIOD + "=" + INTER_CYCLE_REST_PERIOD + ", "
		 + ConfigVars.INTER_MODULE_REST_PERIOD + "=" + INTER_MODULE_REST_PERIOD + ", "
		 + ConfigVars.NUM_INSTRUCTIONS_TO_PROCESS + "=" + NUM_INSTRUCTIONS_TO_PROCESS);
		 */
	}
	
	/** Loops through all loaded modules in turn.
	 * 
	 *  For each enabled module, pending instructions are fetched and locked to the
	 *  module before being processed by the module in turn.
	 *  
	 *  Each locked instruction is processed in it's own transaction block and any 
	 *  updates will be rolled back if there is an error during processing. The error is
	 *  appended to the Error Spooler.
	 *  
	 *  There is a short rest period between execution of each module.
	 * @throws ServiceException 
	 *  
	 * 
	 */
	private void checkModules() {
		busy = true;
		FWFacade cdbFacade = null;
		
		try {
			cdbFacade = CCLAUtils.getFacade(true);
		} catch (Exception e) {
			Log.error("Unable to create handler for SystemDatabase: " 
			 + e.getMessage(), e);
		}
		
		if (cdbFacade == null) {
			busy = false;
			return;
		}
		
		// Check validity of modules list and rebuild if necessary.
		checkModulesListValidity();
		
		long moduleExecutionTimeMillis = MODULE_EXECUTION_TIMEOUT_PERIOD*1000;
		
		// Execute each Routing Module in turn
		for (RoutingModule module : routingModules.values()) {
			
			try {
				//If the manager is paused break out of the cycle
				if (paused)
					break;
				
				if (!module.isEnabled())
					continue;
				
				moduleExecutionStatus = new ModuleExecutionStatus(module);
				moduleExecutionStatus.setExecutionStatus
				 (ModuleExecutionStatus.ExecutionStatus.FETCHING_INSTRUCTIONS);
				
				// Fetch pending instructions for this module
				Vector<Instruction> pendingInstrs = 
				 module.getPendingInstructions(NUM_INSTRUCTIONS_TO_PROCESS, cdbFacade);
				
				moduleExecutionStatus.setNumFetchedInstructions(pendingInstrs.size());
				
				if (!pendingInstrs.isEmpty()) {
					moduleExecutionStatus.setExecutionStatus
					 (ModuleExecutionStatus.ExecutionStatus.PROCESSING);
					
					AbstractModuleHandler handler = module.getModuleHandler();
					
					Log.debug("Routing Module '" + module.getName() + 
					 "': Processing " + pendingInstrs.size() + " instructions");
					
					// Attempt to lock the returned set of instructions. This reassigns
					// the pendingInstrs list with a subset of instructions that were
					// successfully locked.
					pendingInstrs = lockInstructions(module, pendingInstrs, cdbFacade);
					
					// Capture timestamp before the module starts evaluating instructions.
					// This is checked periodically against the module timeout period.
					moduleProcessingStartTime = System.currentTimeMillis();
					int numProcessedInstructions = 0;
					
					boolean doCleanUp = false;
					
					for (Instruction instr : pendingInstrs) {
						if ((System.currentTimeMillis() - moduleProcessingStartTime)
							> moduleExecutionTimeMillis) {
							// Exceeded module execution timeout period. Cancel remaining
							// processing for this module.
							Log.debug("Module Execution timeout reached! " +
							 "Cancelling remaining processing for this module until " +
							 "next cycle");
							doCleanUp = true;
							break;
						}
						
						if (paused) {
							doCleanUp = true;
							break;
						}
						
						// Process each locked instruction in its own transaction
						// block so it doesn't end up in an invalid state.
						cdbFacade.beginTransaction();

						try {
							handler.processInstruction
							 (instr, cdbFacade, RoutingModuleHandler.MODULE_HANDLER_USER);
							
							cdbFacade.commitTransaction();
							
						} catch (Exception e) {
							cdbFacade.rollbackTransaction();
							
							String msg = "Routing Module '" + module.getName() +
							 "' failed to process instruction ID " + 
							 instr.getInstructionId() + ": " + e.getMessage();
							 
							 Log.error(msg, e);
							 // Append error to spooler							 
							 errorSpooler.append(instr, module, e);
							 
							 handler.applyInstructionAction
							  (instr, InstructionAction.SUSPEND, 
							  cdbFacade, RoutingModuleHandler.MODULE_HANDLER_USER);
						}
						
						moduleExecutionStatus.setNumProcessedInstructions
						 (numProcessedInstructions++);
					}
					
					if (doCleanUp) {
						// Perform cleanup.
						moduleExecutionStatus.setExecutionStatus
						 (ModuleExecutionStatus.ExecutionStatus.CLEAN_UP);
						
						// Remove any Instruction Locks created by this module which weren't
						// removed during processing. This covers pause/timeout events which
						// may terminate processing of the fetched instruction prematurely,
						// leaving active locks in place.
						InstructionLockUtils.removeModuleInstructionLocks
						 (module, cdbFacade, Globals.Users.System);
					}
					
					Log.debug("Routing Module '" + module.getName() + 
							 "': Processing completed");
				}
				
				// Clear current execution status
				moduleExecutionStatus = null;
				// Clear execution start time
				moduleProcessingStartTime = null;
				
			} catch (Exception e) {
				Log.error("Unable to process Routing Module " + module.getName() + 
				 ", " + e.getMessage(), e);
			}

			// Rest a bit between each module execution
			try {
				Thread.sleep(INTER_MODULE_REST_PERIOD);
			} catch (InterruptedException e) {}
		}
		 
		// Release CDB connection
		 if (cdbFacade != null)
			 cdbFacade.releaseConnection();
		 
		 // Release SystemDatabase connection, if applicable.
		 //
		 // This will only be relevant if one of the modules instantiated a 
		 // SystemDatabase connection and didn't close it gracefully. If we don't do
		 // the explicit release below, the connection will be tied to this monitor
		 // Thread forever, even if the connection becomes invalid.
		 //
		 // See Calypso issue 611 for more info
		 try {
			FWFacade ucmFacade = null;
	
			ucmFacade = CCLAUtils.getFacade(false);
			ucmFacade.releaseConnection();
			
		} catch (DataException e) {
			Log.error("Failed to create/release SystemDatabase connection: "
			 + e.getMessage(), e);
		}
		
		busy = false;
	}

	/** Locks the passed instruction set to the given module.
	 * 
	 * @param instructions
	 * @param facade
	 * @return the instructions that were successfully locked to the module.
	 */
	public Vector<Instruction> lockInstructions
	 (RoutingModule module, Vector<Instruction> instructions, FWFacade facade) {
		Vector<Instruction> lockedInstructions = new Vector<Instruction>();
		
		for (Instruction instr : instructions) {
			try {
				InstructionLockUtils.lockInstruction
				 (instr.getInstructionId(), module, 
				 facade, Globals.Users.System);
				
				lockedInstructions.add(instr);
				
			} catch (Exception e) {
				String msg = module.getName() + 
				 " Module failed to lock instruction ID: " + instr.getInstructionId();
				
				Log.error(msg, e);
				
				 //obtain the stacktrace in string form
				 StringWriter sw = new StringWriter();
				 e.printStackTrace(new PrintWriter(sw));
				
				 // Append error to spooler
				 getManager().getInstructionErrorSpooler()
				 	.append(instr, module, e.getMessage(),sw.toString());
			}
		}
		
		Log.debug("Locked " + lockedInstructions.size() + "/" + instructions.size() +
		 " instructions to module: " + module.getName());
		
		return lockedInstructions;
	}	
	
	/** Checks the date of the cache that the ordered modules list was based on.
	 *  
	 *  If the date is null, or precedes the current cache date, rebuild the list.
	 *  
	 */
	private void checkModulesListValidity() {
		
		if (lastRoutingModuleRefresh == null
			||
			lastRoutingModuleRefresh.before
			 (RoutingModule.getCache().getLastRefreshed())) {
			buildModulesList();
		}
	}
	
	/**
	 * This method will build the routing modules LinkedList
	 */
	private void buildModulesList() {
		HashMap<Integer, RoutingModule> moduleCache = 
		 RoutingModule.getCache().getCache();
		
		routingModules = new TreeMap<Integer,RoutingModule>();
		
		// use cached SortedMap on executionOrder to gurantee load order.
		for (RoutingModule module : moduleCache.values()) {
			routingModules.put(module.getExecutionOrder(), module);
		}
		
		Log.debug("Built Modules List - " + routingModules.size() +
				" modules loaded");
		
         Iterator<Entry<Integer, RoutingModule>> i = routingModules.entrySet().iterator();

         while(i.hasNext()){
        	 Map.Entry<Integer,RoutingModule> m = i.next();
 			 RoutingModule module = (RoutingModule)m.getValue();
        	 Log.debug(module.getName() + 
        			 (module.isEnabled() ? "": " [DISABLED]"));
         }
		
         lastRoutingModuleRefresh = new Date
		 (RoutingModule.getCache().getLastRefreshed().getTime());
	}

	public void setPaused(boolean paused) {
		if (this.paused != paused) {
			Log.debug("Setting manager pause state: " + paused);
			
			this.paused = paused;
		
			if (!paused)
				dateActive = new Date();
			else
				dateActive = null;
		}
	}

	public boolean isPaused() {
		return paused;
	}

	public void setBusy(boolean busy) {
		this.busy = busy;
	}

	public boolean isBusy() {
		return busy;
	}

	public static void setManager
	 (RoutingModuleManager routingModuleManager) {
		RoutingModuleManager.manager = routingModuleManager;
	}

	public static RoutingModuleManager getManager() {
		return manager;
	}
	
	public int getModuleCount() {
		return this.routingModules.size();
	}
	
	public double getNumCycles() {
		return this.numCycles;
	}
	
	public Date getDateActive() {
		return this.dateActive;
	}

	public void setLastCycle(Date lastCycle) {
		this.lastCycle = lastCycle;
	}

	public Date getLastCycle() {
		return lastCycle;
	}

	public void setIsModulesListStale(Boolean state) {
		this.isModulesListStale = state;
	}

	public Boolean isModulesListStale() {
		return isModulesListStale;
	}
	
	public InstructionErrorSpooler getInstructionErrorSpooler(){
		return errorSpooler;
	}
	
	/** Returns the elapsed time spent processing the current module, in terms of minutes
	 *  and seconds e.g. 2m 30s
	 *  
	 *  Returns null if no module is currently being processed.
	 *  
	 * @return
	 */
	public String getElapsedModuleProcessingExecutionTime() {
		if (moduleProcessingStartTime != null) {
			int totalSeconds =  (int)
			 ((System.currentTimeMillis() - moduleProcessingStartTime)/1000);
			
			int numMinutes = totalSeconds/60;
			int numSeconds = totalSeconds % 60;
			
			return numMinutes + "m " + numSeconds + "s";
		} else {
			return null;
		}
	}
	
}
